<link rel="import" href="/bower_components/polymer/polymer.html" />
<link rel="import" href="/bower_components/iron-ajax/iron-ajax.html" />
<link rel="import" href="/bower_components/paper-input/paper-input.html" />

<script src="/scripts/locale-utils.js"></script>

<dom-module id="file-tree">
	<template>
		<style>
			div.treeElement {
				background-color: #DDFFFF;
				height: 100%;
				width: 100%;
				display:table;
			}

			a:link {
				color: black;
				text-decoration: none;
			}

			a:visited {
				color: black;
			}

			a:hover {
				color: blue;
			}
    	</style>
		<iron-ajax id="treeDataAjax" content-type="application/json"
				on-response="_loadDataOk" on-error="_loadDataError"></iron-ajax>

		<!-- Search -->
		<paper-input label="[[searchLabel]]" on-input="_filter"></paper-input>

		<!-- Tree -->
		<div class="treeElement">
			<template is="dom-repeat" items="[[flatData]]" as="row">
				<div style="[[_generateStyle(row)]]">
					<template is="dom-if" if="[[row.isFolder]]">
						<img alt="Folder" src="icons/folder.png"></img>
					</template>
					<template is="dom-if" if="[[row.isFile]]">
						<img alt="File" src="icons/file.png"></img>
					</template>

					<a href="[[row.encodedUrl]]">
						[[row.name]]
					</a>

					<template is="dom-if" if="[[row.isFile]]">
						[[row.readableSize]]
					</template>
				</div>
			</template>
		</div>
	</template>

	<script>
    Polymer({
    	is: "file-tree",

    	properties: {
    		ajaxUrl: String,
    		downloadUrl: String,
    		searchLabel: String,
    		filter: String,
    		treeData: Object,
    		flatData: Array
    	},

    	ready: function() {
    		this.refresh();
    	},

    	refresh: function() {
    		this._loadData();
    	},

    	_loadData: function() {
    		this.$.treeDataAjax.url = this.ajaxUrl;
    		this.$.treeDataAjax.generateRequest();
    	},

    	_loadDataOk: function(event) {
    		var data = event.detail.response;
    		this.treeData = data;

    		this._referenceToParents(this.treeData);
    		this._applyFilter();
    	},

    	_referenceToParents: function(folder) {
    		for (var i = 0; i < folder.folders.length; i++) {
    			var nextFolder = folder.folders[i];
    			nextFolder.parent = folder;
    			this._referenceToParents(nextFolder);
    		}
    		for (var i = 0; i < folder.files.length; i++) {
    			var file = folder.files[i];
    			file.parent = folder;
    		}
    	},

    	_applyFilter: function() {
    		// Mark each elements in the Tree as non-passed 
    		this._resetFiltered(this.treeData);
    		// Scan and match each element
    		this._filterData(this.treeData);
    		// make flat structure out of passed elements
    		this._makeFlatData();
    	},

    	_resetFiltered: function(folder) {
    		folder.passedFilter = false;
    		for (var i = 0; i < folder.folders.length; i++) {
    			var nextFolder = folder.folders[i];
    			this._resetFiltered(nextFolder);
    		}
    		for (var i = 0; i < folder.files.length; i++) {
    			var file = folder.files[i];
    			file.passedFilter = false;
    		}
    	},

    	_filterData: function(folder) {
    		if (this._match(folder.name)) {
    			this._markBranchPassedFilter(folder);
    			this._markChildrenPassedFilter(folder);
    			return;
    		}

    		for (var i = 0; i < folder.folders.length; i++) {
    			var nextFolder = folder.folders[i];
    			this._filterData(nextFolder);
    		}

	    	for (var i = 0; i < folder.files.length; i++) {
    			var file = folder.files[i];
    			if (this._match(file.name)) {
    				file.passedFilter = true;
    				if (!folder.passedFilter) {
	    				this._markBranchPassedFilter(folder);
    				}
    			}
    		}
    	},

    	_match: function(value) {
    		var result;

    		if (this.filter) {
    			var lowered = value.toLowerCase();
    			result = lowered.includes(this.filter);
    		} else {
    			result = true;
    		}

    		return result;
    	},

    	_markBranchPassedFilter: function(folder) {
    		folder.passedFilter = true;
    		if (folder.parent) {
    			var parent = folder.parent;
    			this._markBranchPassedFilter(parent);
    		}
    	},

		_markChildrenPassedFilter: function(folder) {
			for (var i = 0; i < folder.folders.length; i++) {
    			var nextFolder = folder.folders[i];
    			nextFolder.passedFilter = true;
    			this._markChildrenPassedFilter(nextFolder);
    		}

	    	for (var i = 0; i < folder.files.length; i++) {
    			var file = folder.files[i];
   				file.passedFilter = true;
    		}
		},

    	_makeFlatData: function() {
    		var flat = [];
    		var indent = 0;
    		this._treeToFlatRecursively(this.treeData, flat, indent, "");

    		this.flatData = flat;
    	},

    	_treeToFlatRecursively: function(folder, result, indent, url) {
   			if (folder.passedFilter) {
    			//Add Folder
	    		var node = {};
    			node.name = folder.name;
    			node.indent = indent;
    			node.isFolder = true;
    			node.url = url;
    			node.readableSize = 0;
    			result.push(node);
   			}

    		for (var i = 0; i < folder.folders.length; i++) {
    			//Scan Recursively
    			var nextFolder = folder.folders[i];
    			var nextUrl = url + nextFolder.name + "/";
    			this._treeToFlatRecursively(nextFolder, result, indent + 1, nextUrl);
    		}
    		var index = 0;
    		for (var i = 0; i < folder.files.length; i++) {
    			var file = folder.files[i];

    			if (file.passedFilter) {
    				//Add File
	    			var node = {};
	    			node.name = file.name;
	    			node.indent = indent + 1;
	    			node.isFile = true;
	    			node.index = index++;
	    			var fileUrl = url + file.name;
	    			node.url = fileUrl;
	    			var encodedUrl = this._encodeUrl(fileUrl);
	    			node.encodedUrl = encodedUrl;
	    			node.size = file.size;
	    			var readableSize = this._readableFileSize(file.size);
	    			node.readableSize = readableSize;
	    			result.push(node);
    			}
    		}
    	},

    	_encodeUrl: function(url) {
    		url = encodeURIComponent(url);
    		var encoded = btoa(url);
    		encoded = encoded.replace("/", "_");
    		url = this.downloadUrl + encoded; 
    		return url;
    	},

    	_loadDataError: function(event) {
    		//TODO
    	},

    	_generateStyle: function(row) {
    		var indent = row.indent * 20;
    		var style = "position: relative; left: " + indent + "px;";

    		if (row.isFolder) {
    			// folder
    			style += " background-color: #FFFFBB"
    		} else {
	    		if (row.index % 2 == 0) {
	    			// even
	    			style += " background-color: #DDDDDD;";
	    		} else {
	    			// odd
	    			style += " background-color: white;";
	    		}
    		}

    		return style;
    	},

    	_filter: function(event) {
    		this.filter = event.srcElement.value.toLowerCase();
    		this._applyFilter();
    	},

    	_readableFileSize(row) {
    		var size = row.size;

			if (size < unit) {
				return size + " B";
			}

    		var unit = 1024;
			var exp = Math.log(size) / Math.log(unit);
			exp = Math.floor(exp);
			var suffix = "kMGTPE".charAt(exp - 1);
			var notation = size / Math.pow(unit, exp);
			var result = notation.toFixed(1) + " " + suffix + "B";
    		return result;
    	}
    });
  </script>
</dom-module>
